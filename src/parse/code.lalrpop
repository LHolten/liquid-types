use std::str::FromStr;
use std::rc::Rc;
use crate::parse::expr::*;
use crate::parse::types::*;

grammar;

Num: i32 = {
    r"[0-9]+" => u32::from_str(<>).unwrap() as i32,
    r"'[0-9]'" => <>.as_bytes()[1] as i32,
    r"'\\n'" => 10,
};
Var: String = r"[@]?[_a-zA-Z][_a-zA-z0-9]*" => <>.to_owned();


Value: Value = {
    "(" <UnboxedValue> ")" => <>,
    <Var> <("." <Var>)*> => Value::Var(<>),
    Var Tuple => Value::Struct(<>),
    Num => Value::Int32(<>),
}

UnboxedValue: Value = {
    Value => <>,
    BinOpValue => Value::BinOp(Box::new(<>)),
    Prop => Value::Prop(Box::new(<>)),
};

BinOpValue: BinOpValue = <l:Value> <op:BinOp> <r:Value> => BinOpValue{<>};
BinOp: BinOp = {
    "+" => BinOp::Plus,
    "-" => BinOp::Minus,
    "*" => BinOp::Times,
    "%" => BinOp::Modulo,
    "/" => BinOp::Divide,
    "<<" => BinOp::Shl,
};

Tuple: Vec<Value> = "(" <first:(<UnboxedValue> ",")*> <last:UnboxedValue?> ")" => {
    let mut all = first;
    all.extend(last);
    all
};
Bind: Bind = <func:Var?> <args:Spanned<Tuple>> => Bind{<>};

Let: Let = "let" "(" <names:(<Var> ","?)*> ")" "=" <bind:Bind> => Let{<>};

If: If = "if" <val:UnboxedValue> "{" <block:Block> "}" => If{<>};

Stmt: Stmt = {
    Let => Stmt::Let(<>),
    FuncDef => Stmt::FuncDef(<>),
    If => Stmt::If(<>),
};

BlockInner: Block = {
    <step:Spanned<Stmt>> ";" <next:Block> => Block::Stmt{<>},
    "return" <end:Bind> => Block::End(<>),
};
Block: Rc<Spanned<Block>> = Spanned<BlockInner> => Rc::new(<>);

FuncDef: FuncDef = {
    "fn" <name: Var> <typ:NegTyp> "=" "{" <block:Block> "}" => FuncDef{<>},
    "loop" <name: Var> <typ:PosTyp> "=" "{" <block:Block> "}" => FuncDef{
        name,
        typ: NegTyp {
            args: typ.clone(),
            ret: typ,
        },
        block,
    }
};

pub NegTyp: NegTyp = <args:PosTyp> "->" <ret:PosTyp> => NegTyp{<>};

PosTypInner: PosTyp = "(" <names:(<Param> ","?)*> ")" <parts:("where" "{" <(<Spanned<Constraint>> ";")*> "}")?> => {
    let parts = parts.into_iter().flatten().collect();    
    PosTyp{names, parts}
};
PosTyp: Rc<Spanned<PosTyp>> = Spanned<PosTypInner> => Rc::new(<>);

Param: Param = {
    Var => Param{name: <>, typ: ParamTyp::I32},
    <name:Var> ":" <typ:ParamTyp> => Param{<>},
};
ParamTyp: ParamTyp = <name:Var> => ParamTyp::Custom{<>};
// ParamTyp: ParamTyp = <name:Var> "(" <args:( <ParamTypArg> "," )*> ")" => ParamTyp::Custom{<>};
// ParamTypArg: ParamTypArg = {
//     "_" <("as" <Var>)?> => ParamTypArg::Bind(<>),
//     UnboxedValue => ParamTypArg::Exactly(<>),
// };

Forall: Forall = <named:Var> "for" "(" <names:(<Var> ","?)*> ")" "if" <cond:Prop> => Forall{named, names, cond: Rc::new(cond)};
Switch: Switch = <named:Var> <args:Tuple> <cond:("if" <UnboxedValue>)?> => Switch{<>};

Constraint: Constraint = {
    Forall => Constraint::Forall(<>),
    <(<Var> "=")?> <Switch> => Constraint::Switch(<>),
    "let" <Var> "=" <UnboxedValue> => Constraint::Let(<>),
    <Var> => Constraint::Exactly(<>),
    "assert" <Prop> => Constraint::Assert(<>),
};

Prop: Prop = <l:Value> <op:PropOp> <r:Value> => Prop{<>};
PropOp: PropOp = {
    "<" => PropOp::Less,
    "<=" => PropOp::LessEq,
    "==" => PropOp::Eq,
    "!=" => PropOp::NotEq,
    "&&" => PropOp::And,
    "*?" => PropOp::MulSafe,
};

NamedConstraint: NamedConstraint = "type" <name:Var> <typ:PosTyp> => NamedConstraint{<>};

Def: Def = {
    FuncDef => Def::Func(<>),
    NamedConstraint => Def::Typ(<>),
};

pub Module: Module = Def* => Module(<>);

Spanned<T>: Spanned<T> = {
    <l:@L> <val:T> <r:@R> => Spanned {span: (l, r), val},
};
