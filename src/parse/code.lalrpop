use std::str::FromStr;
use std::rc::Rc;
use crate::parse::expr::*;
use crate::parse::types::*;

grammar;

Num: i32 = r"[0-9]+" => u32::from_str(<>).unwrap() as i32;
Var: String = r"[@]?[_a-zA-Z][_a-zA-z0-9]*" => <>.to_owned();


Value: Value = {
    "(" <UnboxedValue> ")" => <>,
    Var => Value::Var(<>),
    Num => Value::Int32(<>),
}

UnboxedValue: Value = {
    Value => <>,
    BinOpValue => Value::BinOp(Box::new(<>)),
    Prop => Value::Prop(Box::new(<>)),
};

BinOpValue: BinOpValue = <l:Value> <op:BinOp> <r:Value> => BinOpValue{<>};
BinOp: BinOp = {
    "+" => BinOp::Plus,
    "-" => BinOp::Minus,
    "*" => BinOp::Times,
    "%" => BinOp::Modulo,
    "/" => BinOp::Divide,
};

Tuple: Vec<Value> = "(" <(<UnboxedValue> ","?)*> ")" => <>;
Bind: Bind = <func:Var?> <args:Spanned<Tuple>> => Bind{<>};

Let: Let = "let" "(" <names:(<Var> ","?)*> ")" "=" <bind:Bind> => Let{<>};

IfZero: IfZero = "if_zero" <val:Value> "{" <block:Block> "}" => IfZero{<>};

Stmt: Stmt = {
    Let => Stmt::Let(<>),
    FuncDef => Stmt::FuncDef(<>),
    IfZero => Stmt::IfZero(<>),
    "unpack" <Bind> => Stmt::Unpack(<>), 
    "pack" <Bind> => Stmt::Pack(<>), 
};

BlockInner: Block = {
    <step:Spanned<Stmt>> ";" <next:Block> => Block::Stmt{<>},
    "return" <end:Bind> => Block::End(<>),
};
Block: Rc<Spanned<Block>> = Spanned<BlockInner> => Rc::new(<>);

FuncDef: FuncDef = {
    "fn" <name: Var> <typ:NegTyp> "=" "{" <block:Block> "}" => FuncDef{<>},
    "loop" <name: Var> <typ:PosTyp> "=" "{" <block:Block> "}" => FuncDef{
        name,
        typ: NegTyp {
            args: typ.clone(),
            ret: typ,
        },
        block,
    }
};

pub NegTyp: NegTyp = <args:PosTyp> "->" <ret:PosTyp> => NegTyp{<>};

PosTypInner: PosTyp = "(" <names:(<Var> ","?)*> ")" <parts:("where" "{" <(<Spanned<Constraint>> ";")*> "}")?> => {
    let parts = parts.into_iter().flatten().collect();    
    PosTyp{names, parts}
};
PosTyp: Rc<Spanned<PosTyp>> = Spanned<PosTypInner> => Rc::new(<>);

Forall: Forall = <named:Var> "for" "(" <names:(<Var> ","?)*> ")" "if" <cond:Prop> => Forall{named, names, cond: Rc::new(cond)};
Switch: Switch = <named:Var> "(" <args:(<UnboxedValue> ","?)*> ")" "if" <cond:Prop> => Switch{<>};

Constraint: Constraint = {
    Forall => Constraint::Forall(<>),
    Switch => Constraint::Switch(<>),
    <("move" <Var> "=")?> <Bind> => Constraint::Builtin(<>),
    "assert" <Prop> => Constraint::Assert(<>),
};

Prop: Prop = <l:Value> <op:PropOp> <r:Value> => Prop{<>};
PropOp: PropOp = {
    "<" => PropOp::Less,
    "<=" => PropOp::LessEq,
    "==" => PropOp::Eq,
    "!=" => PropOp::NotEq,
    "&&" => PropOp::And,
    "*?" => PropOp::MulSafe,
};

NamedConstraint: NamedConstraint = "type" <name:Var> <typ:PosTyp> => NamedConstraint{<>};

Def: Def = {
    FuncDef => Def::Func(<>),
    NamedConstraint => Def::Typ(<>),
};

pub Module: Module = Def* => Module(<>);

Spanned<T>: Spanned<T> = {
    <l:@L> <val:T> <r:@R> => Spanned {span: (l, r), val},
};
