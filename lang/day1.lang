type array(from, len) where {
    @byte for (ptr) if (ptr - from) < len;
}

type arrayln(from, len) where {
    assert 1 <= len;
    move last = @byte(from + (len - 1));
    assert last == 10;
    array(from, len - 1);
}

fn part1(len) where {
    arrayln(0, len);
} -> (out) where {
    arrayln(0, len);
} = {
    loop inner(sum, idx) where {
        assert idx <= len;
        arrayln(0, len);
    } = {
        if_zero (idx != len) {
            return (sum, idx)
        };

        loop find_first(idx, prev) where {
            assert idx < len;
            arrayln(0, len);
        } = {
            let (val) = @read_u8(idx);
            if_zero (val != 10) {
                return (idx, prev)
            };
            if_zero ((48 <= val) && (val <= 57)) {
                return find_first(idx + 1, prev)
            };
            return (idx + 1, val - 48)
        };

        loop find_last(idx, prev) where {
            assert idx < len;
            arrayln(0, len);
        } = {
            let (val) = @read_u8(idx);
            if_zero (val != 10) {
                return (idx, prev)
            };
            if_zero ((48 <= val) && (val <= 57)) {
                return find_last(idx + 1, prev)
            };
            return find_last(idx + 1, val - 48)
        };

        let (idx, first) = find_first(idx, 0);
        let (idx, last) = find_last(idx, first);
        return inner(sum + ((10 * first) + last), idx + 1)
    };

    let (sum, end) = inner(0, 0);
    return (sum)
}